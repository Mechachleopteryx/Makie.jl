<!doctype html> <!-- Minimal Mistakes Jekyll Theme 4.16.4 by Michael Rose Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes Free for personal and commercial use under the MIT license https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE --> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/previews/PR1181/libs/highlight/github.min.css"> <link rel=stylesheet  href="/previews/PR1181/css/franklin.css"> <link rel=stylesheet  href="/previews/PR1181/css/minimal-mistakes.css"> <link rel=stylesheet  href="/previews/PR1181/css/makie.css"> <link rel=icon  href="/previews/PR1181/assets/icon_transparent.png"> <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel=stylesheet  type="text/css"/> <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel=stylesheet  type="text/css"/> <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel=stylesheet  type="text/css"/> <!--[if IE ]> <style> /* old IE unsupported flexbox fixes */ .greedy-nav .site-title { padding-right: 3em; } .greedy-nav button { position: absolute; top: 0; right: 0; height: 100%; } </style> <![endif]--> <title>How to use JSServe &#43; WGLMakie</title> <body class=layout--single > <div class=masthead > <div class=masthead__inner-wrap > <div class=masthead__menu > <nav id=site-nav  class=greedy-nav > <a class=title-icon  href="/previews/PR1181/"><img src="/previews/PR1181/assets/makie_logo_transparent.svg"/></a> <ul class=visible-links > <li class=masthead__menu-item > <a href="https://github.com/JuliaPlots/Makie.jl"><img src="/previews/PR1181/assets/GitHub-Mark-64px.png" class=masthead-icon  /></a> <li class=masthead__menu-item ><a href="/previews/PR1181/examples/">Examples</a> <li class=masthead__menu-item ><a href="/previews/PR1181/tutorials/">Tutorials</a> <li class=masthead__menu-item ><a href="/previews/PR1181/documentation/">Documentation</a> </ul> <button class="greedy-nav__toggle hidden" type=button > <span class=visually-hidden >Toggle menu</span> <div class=navicon ></div> </button> <ul class="hidden-links hidden"></ul> </nav> </div> </div> </div> <div class=initial-content > <div id=main  role=main > <div class=franklin-content ><h1 id=how_to_use_jsserve_wglmakie ><a href="#how_to_use_jsserve_wglmakie" class=header-anchor >How to use JSServe &#43; WGLMakie</a></h1> <p>One can use JSServe and WGLMakie in Pluto, IJulia, Webpages - and Documenter&#33; It&#39;s possible to create interactive apps and dashboards, serve them on live webpages, or export them to static HTML.</p> <p>This tutorial will run through the different modes and what kind of limitations to expect.</p> <p>First, one should use the new Page mode for anything that displays multiple outputs, like Pluto/IJulia/Documenter. This creates a single entry point, to connect to the Julia process and load dependencies. For Documenter, the page needs to be set to <code>exportable&#61;true, offline&#61;true</code>. Exportable has the effect of inlining all data &amp; js dependencies, so that everything can be loaded in a single HTML object. <code>offline&#61;true</code> will make the Page not even try to connect to a running Julia process, which makes sense for the kind of static export we do in Documenter.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> JSServe
Page(exportable=<span class=hljs-literal >true</span>, offline=<span class=hljs-literal >true</span>)</code></pre> <p>After the page got displayed by the frontend, we can start with creating plots and JSServe Apps:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> WGLMakie
WGLMakie.activate!()
<span class=hljs-comment ># Set the default resolution to something that fits the Documenter theme</span>
set_theme!(resolution=(<span class=hljs-number >800</span>, <span class=hljs-number >400</span>))
scatter(<span class=hljs-number >1</span>:<span class=hljs-number >4</span>, color=<span class=hljs-number >1</span>:<span class=hljs-number >4</span>)</code></pre> <p>As you can see, the output is completely static, because we don&#39;t have a running Julia server, as it would be the case with e.g. Pluto. To make the plot interactive, we will need to write more parts of WGLMakie in JS, which is an ongoing effort. As you can see, the interactivity already keeps working for 3D:</p> <pre><code class="julia hljs">N = <span class=hljs-number >60</span>
<span class=hljs-keyword >function</span> xy_data(x, y)
    r = sqrt(x^<span class=hljs-number >2</span> + y^<span class=hljs-number >2</span>)
    r == <span class=hljs-number >0.0</span> ? <span class=hljs-number >1f0</span> : (sin(r)/r)
<span class=hljs-keyword >end</span>
l = range(-<span class=hljs-number >10</span>, stop = <span class=hljs-number >10</span>, length = N)
z = <span class=hljs-built_in >Float32</span>[xy_data(x, y) <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> l, y <span class=hljs-keyword >in</span> l]
surface(
    -<span class=hljs-number >1.</span><span class=hljs-number >.1</span>, -<span class=hljs-number >1.</span><span class=hljs-number >.1</span>, z,
    colormap = :Spectral
)</code></pre> <p>There are a couple of ways to keep interacting with Plots in a static export.</p> <h2 id=record_a_statemap ><a href="#record_a_statemap" class=header-anchor >Record a statemap</a></h2> <p>JSServe allows to record a statemap for all widgets, that satisfy the following interface:</p> <pre><code class="julia hljs"><span class=hljs-comment ># must be true to be found inside the DOM</span>
is_widget(x) = <span class=hljs-literal >true</span>
<span class=hljs-comment ># Updating the widget isn&#x27;t dependant on any other state (only thing supported right now)</span>
is_independant(x) = <span class=hljs-literal >true</span>
<span class=hljs-comment ># The values a widget can iterate</span>
<span class=hljs-keyword >function</span> value_range <span class=hljs-keyword >end</span>
<span class=hljs-comment ># updating the widget with a certain value (usually an observable)</span>
<span class=hljs-keyword >function</span> update_value!(x, value) <span class=hljs-keyword >end</span></code></pre> <p>Currently, only sliders overload the interface:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Observables

App() <span class=hljs-keyword >do</span> session::Session
    n = <span class=hljs-number >10</span>
    index_slider = Slider(<span class=hljs-number >1</span>:n)
    volume = rand(n, n, n)
    slice = map(index_slider) <span class=hljs-keyword >do</span> idx
        <span class=hljs-keyword >return</span> volume[:, :, idx]
    <span class=hljs-keyword >end</span>
    fig = Figure()
    ax, cplot = contour(fig[<span class=hljs-number >1</span>, <span class=hljs-number >1</span>], volume)
    rectplot = linesegments!(ax, Rect(-<span class=hljs-number >1</span>, -<span class=hljs-number >1</span>, <span class=hljs-number >12</span>, <span class=hljs-number >12</span>), linewidth=<span class=hljs-number >2</span>, color=:red)
    on(index_slider) <span class=hljs-keyword >do</span> idx
        translate!(rectplot, <span class=hljs-number >0</span>,<span class=hljs-number >0</span>,idx)
    <span class=hljs-keyword >end</span>
    heatmap(fig[<span class=hljs-number >1</span>, <span class=hljs-number >2</span>], slice)
    slider = DOM.div(<span class=hljs-string >&quot;z-index: &quot;</span>, index_slider, index_slider.value)
    <span class=hljs-keyword >return</span> JSServe.record_states(session, DOM.div(slider, fig))
<span class=hljs-keyword >end</span></code></pre> <h2 id=execute_javascript_directly ><a href="#execute_javascript_directly" class=header-anchor >Execute Javascript directly</a></h2> <p>JSServe makes it easy to build whole HTML and JS applications. You can for example directly register javascript function that get run on change.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> JSServe: onjs

app = App() <span class=hljs-keyword >do</span> session::Session
    s1 = Slider(<span class=hljs-number >1</span>:<span class=hljs-number >100</span>)
    slider_val = DOM.p(s1[]) <span class=hljs-comment ># initialize with current value</span>
    <span class=hljs-comment ># call the `on_update` function whenever s1.value changes in JS:</span>
    onjs(session, s1.value, <span class=hljs-string >js&quot;&quot;&quot;function on_update(new_value) {
        //interpolating of DOM nodes and other Julia values work mostly as expected:
        const p_element = <span class=hljs-subst >$(slider_val)</span>
        p_element.innerText = new_value
    }
    &quot;&quot;&quot;</span>)

    <span class=hljs-keyword >return</span> DOM.div(<span class=hljs-string >&quot;slider 1: &quot;</span>, s1, slider_val)
<span class=hljs-keyword >end</span></code></pre> <p>One can also interpolate plots into JS and update those via JS. The problem is, that there isn&#39;t an amazing interface yet. The returned object is directly a THREE object, with all plot attributes converted into Javascript types. The good news is, all attributes should be in either <code>three_scene.material.uniforms</code>, or <code>three_scene.geometry.attributes</code>. Going forward, we should create an API in WGLMakie, that makes it as easy as in Julia: <code>plot.attribute &#61; value</code>. But while this isn&#39;t in place, logging the the returned object makes it pretty easy to figure out what to do - btw, the JS console &#43; logging is amazing and makes it very easy to play around with the object once logged.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> JSServe: onjs, evaljs, on_document_load

app = App() <span class=hljs-keyword >do</span> session::Session
    s1 = Slider(<span class=hljs-number >1</span>:<span class=hljs-number >100</span>)
    slider_val = DOM.p(s1[]) <span class=hljs-comment ># initialize with current value</span>

    fig, ax, splot = scatter(<span class=hljs-number >1</span>:<span class=hljs-number >4</span>)

    <span class=hljs-comment ># With on_document_load one can run JS after everything got loaded.</span>
    <span class=hljs-comment ># This is an alternative to `evaljs`, which we can&#x27;t use here,</span>
    <span class=hljs-comment ># since it gets run asap, which means the plots won&#x27;t be found yet.</span>

    on_document_load(session, <span class=hljs-string >js&quot;&quot;&quot;
        const plots = <span class=hljs-subst >$(splot)</span>
        const scatter_plot = plots[0]
        // open the console with ctr+shift+i, to inspect the values
        // tip - you can right click on the log and store the actual variable as a global, and directly interact with it to change the plot.
        console.log(scatter_plot)
        console.log(scatter_plot.material.uniforms)
        console.log(scatter_plot.geometry.attributes)
    &quot;&quot;&quot;</span>)

    <span class=hljs-comment ># with the above, we can find out that the positions are stored in `offset`</span>
    <span class=hljs-comment ># (*sigh*, this is because threejs special cases `position` attributes so it can&#x27;t be used)</span>
    <span class=hljs-comment ># Now, lets go and change them when using the slider :)</span>
    onjs(session, s1.value, <span class=hljs-string >js&quot;&quot;&quot;function on_update(new_value) {
        const plots = <span class=hljs-subst >$(splot)</span>
        const scatter_plot = plots[0]

        // change first point x + y value
        scatter_plot.geometry.attributes.offset.array[0] = (new_value/100) * 4
        scatter_plot.geometry.attributes.offset.array[1] = (new_value/100) * 4
        // this always needs to be set of geometry attributes after an update
        scatter_plot.geometry.attributes.offset.needsUpdate = true
    }
    &quot;&quot;&quot;</span>)
    <span class=hljs-comment ># and for got measures, add a slider to change the color:</span>
    color_slider = Slider(<span class=hljs-built_in >LinRange</span>(<span class=hljs-number >0</span>, <span class=hljs-number >1</span>, <span class=hljs-number >100</span>))
    onjs(session, color_slider.value, <span class=hljs-string >js&quot;&quot;&quot;function on_update(hue) {
        const plot = <span class=hljs-subst >$(splot)</span>[0]
        const color = new THREE.Color()
        color.setHSL(hue, 1.0, 0.5)
        plot.material.uniforms.color.value.x = color.r
        plot.material.uniforms.color.value.y = color.g
        plot.material.uniforms.color.value.z = color.b
    }&quot;&quot;&quot;</span>)

    markersize = Slider(<span class=hljs-number >1</span>:<span class=hljs-number >100</span>)
    onjs(session, markersize.value, <span class=hljs-string >js&quot;&quot;&quot;function on_update(size) {
        const plot = <span class=hljs-subst >$(splot)</span>[0]
        plot.material.uniforms.markersize.value.x = size
        plot.material.uniforms.markersize.value.y = size
    }&quot;&quot;&quot;</span>)
    <span class=hljs-keyword >return</span> DOM.div(s1, color_slider, markersize, fig)
<span class=hljs-keyword >end</span></code></pre> <p>This summarizes the current state of interactivity with WGLMakie inside static pages.</p> <h1 id=plutoijulia ><a href="#plutoijulia" class=header-anchor >Pluto/IJulia</a></h1> <p>Note that the normal interactivity from Makie is preserved with WGLMakie in e.g. Pluto, as long as the Julia session is running. Which brings us to setting up Pluto/IJulia sessions&#33; The return value of your first cell must be the return value of the function <code>Page</code>. For example, your first cell can be</p> <pre><code class="julia hljs"><span class=hljs-keyword >begin</span>
	<span class=hljs-keyword >using</span> JSServe
	Page()
<span class=hljs-keyword >end</span></code></pre> <p>As is common with files meant to be shared, you might wish to set up a temporary directory so as to not pollute other people&#39;s environment. The following code will also be a valid first cell.</p> <pre><code class="julia hljs"><span class=hljs-keyword >begin</span>
	<span class=hljs-keyword >using</span> Pkg
	Pkg.activate(mktempdir())

	Pkg.add(<span class=hljs-string >&quot;JSServe&quot;</span>)
	<span class=hljs-keyword >using</span> JSServe
	Page()
<span class=hljs-keyword >end</span></code></pre> <p>If you&#39;re accessing the notebook from another PC, you must set:</p> <pre><code class="julia hljs"><span class=hljs-keyword >begin</span>
	<span class=hljs-keyword >using</span> JSServe
	Page(listen_url=<span class=hljs-string >&quot;0.0.0.0&quot;</span>)
<span class=hljs-keyword >end</span></code></pre> <p>For more advanced setups consult the <code>?Page</code> docs and <code>JSServe.configure_server&#33;</code>.</p> <h2 id=styling ><a href="#styling" class=header-anchor >Styling</a></h2> <p>You may have noticed, styling isn&#39;t really amazing right now. The good news is, that one can use the whole mighty power of the CSS/HTML universe. If it wasn&#39;t clear so far, JSServe allows to load arbitrary css, and <code>DOM.xxx</code> wraps all existing HTML tags.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Colors
<span class=hljs-keyword >using</span> JSServe: rows

App() <span class=hljs-keyword >do</span> session::Session

    hue_slider = Slider(<span class=hljs-number >0</span>:<span class=hljs-number >360</span>)
    color_swatch = DOM.div(class=<span class=hljs-string >&quot;h-6 w-6 p-2 m-2 rounded shadow&quot;</span>)

    onjs(session, hue_slider.value, <span class=hljs-string >js&quot;&quot;&quot;function (hue){
        <span class=hljs-subst >$(color_swatch)</span>.style.backgroundColor = &quot;hsl(&quot; + hue + &quot;,60%,50%)&quot;
    }&quot;&quot;&quot;</span>)

    <span class=hljs-keyword >return</span> DOM.div(JSServe.TailwindCSS, rows(hue_slider, color_swatch))
<span class=hljs-keyword >end</span></code></pre> <p>Tailwind is quite a amazing and has a great documentation especially for CSS beginners: https://tailwindcss.com/docs/</p> <p>Note, that JSServe.TailwindCSS is nothing but:</p> <pre><code class="julia hljs">TailwindCSS = JSServe.Asset(<span class=hljs-string >&quot;/path/to/tailwind.min.css&quot;</span>)</code></pre>
<p>So any other CSS file can be used.</p>
<p>It&#39;s also pretty easy to make reusable blocks from styled elements. E.g. the <code>rows</code> function above is nothing but:</p>
<pre><code class="julia hljs">rows(args...; class=<span class=hljs-string >&quot;&quot;</span>) = DOM.div(args..., class=class * <span class=hljs-string >&quot; flex flex-row&quot;</span>)</code></pre>
<p>It would be more correct to define it as:</p>
<pre><code class="julia hljs">rows(args...; class=<span class=hljs-string >&quot;&quot;</span>) = DOM.div(JSServe.TailwindCSS, args..., class=class * <span class=hljs-string >&quot; flex flex-row&quot;</span>)</code></pre>
<p>JSServe will then make sure, that <code>JSServe.TailwindCSS</code> is loaded, and will only load it once&#33;</p>
<p>Finally, lets create a styled, reusable card componenent:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Markdown

<span class=hljs-keyword >struct</span> GridCard
    elements::<span class=hljs-built_in >Any</span>
<span class=hljs-keyword >end</span>

GridCard(elements...) = GridCard(elements)

<span class=hljs-keyword >function</span> JSServe.jsrender(card::GridCard)
    <span class=hljs-keyword >return</span> DOM.div(JSServe.TailwindCSS, card.elements..., class=<span class=hljs-string >&quot;rounded-lg p-2 m-2 shadow-lg grid auto-cols-max grid-cols-2 gap-4&quot;</span>)
<span class=hljs-keyword >end</span>

App() <span class=hljs-keyword >do</span> session::Session
    <span class=hljs-comment ># We can now use this wherever we want:</span>
    fig = Figure(resolution=(<span class=hljs-number >200</span>, <span class=hljs-number >200</span>))
    contour(fig[<span class=hljs-number >1</span>,<span class=hljs-number >1</span>], rand(<span class=hljs-number >4</span>,<span class=hljs-number >4</span>))
    card = GridCard(
        Slider(<span class=hljs-number >1</span>:<span class=hljs-number >100</span>),
        DOM.h1(<span class=hljs-string >&quot;hello&quot;</span>),
        DOM.img(src=<span class=hljs-string >&quot;https://julialang.org/assets/infra/logo.svg&quot;</span>),
        fig
    )
    <span class=hljs-comment ># Markdown creates a DOM as well, and you can interpolate</span>
    <span class=hljs-comment ># arbitrary jsrender&#x27;able elements in there:</span>
    <span class=hljs-keyword >return</span> <span class=hljs-string >md&quot;&quot;&quot;

    # Wow, Markdown works as well?

    <span class=hljs-subst >$(card)</span>

    &quot;&quot;&quot;</span>
<span class=hljs-keyword >end</span></code></pre>
<p>Hopefully, over time there will be helper libraries with lots of stylised elements like the above, to make flashy dashboards with JSServe &#43; WGLMakie.</p>
<h1 id=export ><a href="#export" class=header-anchor >Export</a></h1>
<p>Documenter just renders the plots &#43; Page as html, so if you want to inline WGLMakie/JSServe objects into your own page, one can just use something like this:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> WGLMakie, JSServe

<span class=hljs-keyword >using</span> WGLMakie, JSServe
WGLMakie.activate!()

open(<span class=hljs-string >&quot;index.html&quot;</span>, <span class=hljs-string >&quot;w&quot;</span>) <span class=hljs-keyword >do</span> io
    println(io, <span class=hljs-string >&quot;&quot;&quot;
    &lt;html&gt;
        &lt;head&gt;
        &lt;/head&gt;
        &lt;body&gt;
    &quot;&quot;&quot;</span>)
    <span class=hljs-comment ># before doing anything else,</span>
    <span class=hljs-comment ># make sure the Page setup code gets rendered as HTML</span>
    show(io, <span class=hljs-string >MIME&quot;text/html&quot;</span>(), Page(exportable=<span class=hljs-literal >true</span>, offline=<span class=hljs-literal >true</span>))
    <span class=hljs-comment ># Then, you can just inline plots or whatever you want :)</span>
    show(io, <span class=hljs-string >MIME&quot;text/html&quot;</span>(), scatter(<span class=hljs-number >1</span>:<span class=hljs-number >4</span>))
    show(io, <span class=hljs-string >MIME&quot;text/html&quot;</span>(), surface(rand(<span class=hljs-number >4</span>, <span class=hljs-number >4</span>)))
    <span class=hljs-comment ># or anything else from JSServe, or that can be displayed as html:</span>
    show(io, <span class=hljs-string >MIME&quot;text/html&quot;</span>(), JSServe.Slider(<span class=hljs-number >1</span>:<span class=hljs-number >3</span>))
    println(io, <span class=hljs-string >&quot;&quot;&quot;
        &lt;/body&gt;
    &lt;/html&gt;
    &quot;&quot;&quot;</span>)
<span class=hljs-keyword >end</span></code></pre>
<h1 id=troubleshooting ><a href="#troubleshooting" class=header-anchor >Troubleshooting</a></h1>
<h2 id=plots_dont_display_in_safari ><a href="#plots_dont_display_in_safari" class=header-anchor >Plots don&#39;t display in Safari</a></h2>
<p>Safari users may need to <a href="https://discussions.apple.com/thread/8655829">enable</a> WebGL.</p>
<div class=page-foot >
  <div class=copyright >
    &copy; Makie.jl. Last modified: July 30, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>

      </div> 
    </div>   

    <div class=page__footer >
      <footer>
        
        
        <div class=page__footer-follow >
          <ul class=social-icons >
            <li><a href="https://twitter.com/MakiePlots" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden=true ></i> Twitter</a>
            <li><a href="https://github.com/JuliaPlots/Makie.jl" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden=true ></i> GitHub</a>
          </ul>
        </div>
        <div class=page__footer-copyright >&copy; Makie.jl. Powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel=nofollow >Minimal Mistakes</a>.</div>
      </footer>
    </div>

    <script src="/previews/PR1181/libs/minimal-mistakes/main.min.js"></script>
    <script defer src="https://use.fontawesome.com/releases/v5.8.2/js/all.js" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" crossorigin=anonymous ></script>